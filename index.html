<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
<title>TBFL_6 — Web Audio Visualizer</title>

<!-- Three.js CDN -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/renderers/CSS2DRenderer.js"></script>

<style>
  html,body { height:100%; margin:0; background:#000; color:#00FF00; font-family: monospace; }
  #ui {
    position: absolute; left:12px; top:12px; z-index: 10;
    background: rgba(0,0,0,0.45); border:1px solid #004400; padding:8px; border-radius:6px;
  }
  button, label { color:#00FF00; background:transparent; border:1px solid #003300; padding:6px 8px; margin:4px; border-radius:4px; cursor:pointer; }
  input[type=file] { display:none; }
  #title { font-weight:bold; font-size:14px; color:#00FF00; display:block; margin-bottom:6px; }
  #hint { font-size:11px; color:#88ff88; opacity:0.6; margin-top:6px; }
  canvas { display:block; }
  .coord-label { font-size:10px; color:#00FF00; text-shadow: 0 0 4px rgba(0,255,0,0.4); }
</style>
</head>

<body>

<!-- UI -->
<div id="ui">
  <div id="title">TBFL_6 — Web Visualizer</div>
  <button id="btn-mic">Mikrofon (Live)</button>
  <label for="wavfile">WAV laden</label>
  <input id="wavfile" type="file" accept=".wav,audio/wav" />
  <button id="btn-stop">Stop</button>
  <div id="hint">Auf iOS/Safari muss Audio per Touch gestartet werden. HTTPS erforderlich.</div>
</div>


<script>
// ============================================================================
// iOS / SAFARI AUDIO FIX — MUSS GANZ OBEN STEHEN
// ============================================================================
let audioCtx = null;

document.addEventListener("touchstart", () => {
  if (audioCtx && audioCtx.state === "suspended") {
    audioCtx.resume();
  }
}, { once: true });


// ============================================================================
// THREE.JS SETUP
// ============================================================================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 10000);
camera.position.set(0, 300, 800);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(window.devicePixelRatio || 1);
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

const labelRenderer = new THREE.CSS2DRenderer();
labelRenderer.setSize(innerWidth, innerHeight);
labelRenderer.domElement.style.position = "absolute";
labelRenderer.domElement.style.top = "0px";
labelRenderer.domElement.style.pointerEvents = "none";
document.body.appendChild(labelRenderer.domElement);

const controls = new THREE.OrbitControls(camera, labelRenderer.domElement);
controls.enabled = false;

const ambient = new THREE.AmbientLight(0x00ff00, 0.08);
scene.add(ambient);

const gridHelper = new THREE.GridHelper(2000, 40, 0x003300, 0x003300);
gridHelper.material.opacity = 0.06;
gridHelper.material.transparent = true;
scene.add(gridHelper);


// ============================================================================
// AUDIO VARIABLES
// ============================================================================
let analyser = null;
let sourceNode = null;
let dataArray = null;
let freqBinCount = 0;
let running = false;

const FFT_SIZE = 2048;
const NOISE_THRESHOLD = 0.0015;

const maxPoints = 40;
const freqs = [];
const louds = [];
const cents = [];


// ============================================================================
// GEOMETRY (POINT CLOUD + LINES)
// ============================================================================
const maxCapacity = maxPoints;
const positions = new Float32Array(maxCapacity * 3);
const colors = new Float32Array(maxCapacity * 3);
const sizes = new Float32Array(maxCapacity);

const geometry = new THREE.BufferGeometry();
geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3).setUsage(THREE.DynamicDrawUsage));
geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3).setUsage(THREE.DynamicDrawUsage));
geometry.setAttribute("size", new THREE.BufferAttribute(sizes, 1).setUsage(THREE.DynamicDrawUsage));

const material = new THREE.ShaderMaterial({
  vertexColors: true,
  transparent: true,
  depthTest: true,
  uniforms: { pointScale: { value: window.innerHeight / 2 } },
  vertexShader: `
      attribute float size;
      varying vec3 vColor;
      void main(){
        vColor = color;
        vec4 mvPosition = modelViewMatrix * vec4(position,1.0);
        gl_Position = projectionMatrix * mvPosition;
        gl_PointSize = size * (300.0 / -mvPosition.z);
      }
    `,
  fragmentShader: `
      varying vec3 vColor;
      void main(){
        gl_FragColor = vec4(vColor,1.0);
      }
    `
});

const points = new THREE.Points(geometry, material);
scene.add(points);

const linePositions = new Float32Array((maxCapacity - 1) * 2 * 3);
const lineGeom = new THREE.BufferGeometry();
lineGeom.setAttribute("position", new THREE.BufferAttribute(linePositions, 3).setUsage(THREE.DynamicDrawUsage));
const lineMat = new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.9 });
const lines = new THREE.LineSegments(lineGeom, lineMat);
scene.add(lines);


// ============================================================================
// HELPER FUNCTIONS
// ============================================================================
const FMIN = 20, FMAX = 22050;

function freqToX(f){
  const t = (Math.log10(Math.max(f,FMIN)) - Math.log10(FMIN)) / (Math.log10(FMAX) - Math.log10(FMIN));
  return (t - 0.5) * 1400;
}
function centroidToY(c){ return (c/2000)*800; }
function loudToZ(l){ return Math.min(Math.max(l*5,0.001),1.5); }

function computeRMS(arr){
  let s=0;
  for(let i=0;i<arr.length;i++) s+=arr[i]*arr[i];
  return Math.sqrt(s/arr.length);
}

function computeCentroid(mags, freq){
  let num=0, den=0;
  for(let i=0;i<mags.length;i++){
    num += mags[i]*freq[i];
    den += mags[i];
  }
  return den>0 ? num/den : 0;
}


// ============================================================================
// AUDIO START (MIC)
// ============================================================================
async function startMic() {
  if (running) return;

  // AudioContext muss durch Klick aktiv sein
  if (!audioCtx)
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  if (audioCtx.state === "suspended")
      await audioCtx.resume();

  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      audio: {
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false
      }
    });

    sourceNode = audioCtx.createMediaStreamSource(stream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = FFT_SIZE;
    analyser.smoothingTimeConstant = 0.65;

    freqBinCount = analyser.frequencyBinCount;
    dataArray = new Float32Array(freqBinCount);

    sourceNode.connect(analyser);
    running = true;

  } catch (err) {
    alert("Mikrofon konnte nicht gestartet werden:\n" + err.message);
  }
}


// ============================================================================
// AUDIO: WAV FILE
// ============================================================================
async function startWav(file){
  if (running) stopAll();

  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const buf = await file.arrayBuffer();
  const decoded = await audioCtx.decodeAudioData(buf);

  const bs = audioCtx.createBufferSource();
  bs.buffer = decoded;

  analyser = audioCtx.createAnalyser();
  analyser.fftSize = FFT_SIZE;
  analyser.smoothingTimeConstant = 0.65;

  freqBinCount = analyser.frequencyBinCount;
  dataArray = new Float32Array(freqBinCount);

  bs.connect(analyser);
  analyser.connect(audioCtx.destination);

  bs.start();
  running = true;

  bs.onended = () => running = false;
}


// ============================================================================
// STOP AUDIO
// ============================================================================
function stopAll(){
  running = false;
  try{ if(sourceNode && sourceNode.stop) sourceNode.stop(); }catch(e){}
  try{ if(audioCtx) audioCtx.close(); }catch(e){}
  analyser = sourceNode = audioCtx = null;
}


// ============================================================================
// UI EVENTS
// ============================================================================
document.getElementById("btn-mic").onclick = startMic;
document.getElementById("btn-stop").onclick = stopAll;

document.getElementById("wavfile").addEventListener("change", e => {
  if (e.target.files[0]) startWav(e.target.files[0]);
});


// ============================================================================
// ANIMATION LOOP
// ============================================================================
let rot = 0;
let lastTime = performance.now();

function animate(t){
  requestAnimationFrame(animate);

  const dt = (t - lastTime)/1000;
  lastTime = t;

  rot += 0.3 * dt * 60;
  camera.position.x = Math.sin(rot*0.01)*800;
  camera.position.z = Math.cos(rot*0.01)*800;
  camera.lookAt(0,200,0);

  if(running && analyser){
    const timeData = new Float32Array(analyser.fftSize);
    analyser.getFloatTimeDomainData(timeData);
    const rms = computeRMS(timeData);

    const freqDb = new Float32Array(freqBinCount);
    analyser.getFloatFrequencyData(freqDb);

    const mags = new Float32Array(freqBinCount);
    const binFreqs = new Float32Array(freqBinCount);

    const nyquist = audioCtx.sampleRate/2;
    for(let i=0;i<freqBinCount;i++){
      mags[i] = Math.pow(10, freqDb[i]/20);
      binFreqs[i] = (i/freqBinCount)*nyquist;
    }

    let maxIdx = 0;
    let maxVal = -Infinity;
    for(let i=0;i<mags.length;i++){
      if(mags[i] > maxVal){ maxVal=mags[i]; maxIdx=i; }
    }

    const peak = binFreqs[maxIdx] || 0;
    const centroid = computeCentroid(mags, binFreqs);

    if(rms >= NOISE_THRESHOLD){
      if(freqs.length >= maxPoints){ freqs.shift(); louds.shift(); cents.shift(); }
      freqs.push(peak);
      louds.push(rms);
      cents.push(centroid);
    }
  }

  const n = freqs.length;

  for(let i=0;i<maxCapacity;i++){
    const p = i*3;

    if(i < n){
      const x = freqToX(freqs[i]);
      const y = centroidToY(cents[i]);
      const z = loudToZ(louds[i]);

      positions[p]=x; positions[p+1]=y; positions[p+2]=z;

      const age = i / Math.max(1,n-1);
      colors[p] = age*0.2;
      colors[p+1] = age;
      colors[p+2] = 0;

      sizes[i] = 8;

    } else {
      positions[p]=positions[p+1]=positions[p+2]=1e6;
      sizes[i]=0;
    }
  }

  geometry.attributes.position.needsUpdate = true;
  geometry.attributes.color.needsUpdate = true;
  geometry.attributes.size.needsUpdate = true;

  let lp=0;
  for(let i=0;i<n-1;i++){
    const A=i*3, B=(i+1)*3;
    linePositions[lp++] = positions[A];
    linePositions[lp++] = positions[A+1];
    linePositions[lp++] = positions[A+2];
    linePositions[lp++] = positions[B];
    linePositions[lp++] = positions[B+1];
    linePositions[lp++] = positions[B+2];
  }
  for(;lp<linePositions.length;lp++) linePositions[lp]=1e6;
  lineGeom.attributes.position.needsUpdate = true;

  renderer.render(scene, camera);
  labelRenderer.render(scene, camera);
}

requestAnimationFrame(animate);


// ============================================================================
// RESIZE
// ============================================================================
window.addEventListener("resize", ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  labelRenderer.setSize(innerWidth, innerHeight);
});

console.log("TBFL_6 Web Visualizer ready.");

</script>

</body>
</html>
