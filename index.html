<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
<title>TBFL_6 — Web Audio Visualizer</title>
<!-- Three.js CDN -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/renderers/CSS2DRenderer.js"></script>
<style>
  html,body { height:100%; margin:0; background:#000; color:#00FF00; font-family: monospace; }
  #ui {
    position: absolute; left:12px; top:12px; z-index: 10;
    background: rgba(0,0,0,0.45); border:1px solid #004400; padding:8px; border-radius:6px;
  }
  button, label { color:#00FF00; background:transparent; border:1px solid #003300; padding:6px 8px; margin:4px; border-radius:4px; cursor:pointer; }
  input[type=file] { display:none; }
  #title { font-weight:bold; font-size:14px; color:#00FF00; display:block; margin-bottom:6px; }
  #hint { font-size:11px; color:#88ff88; opacity:0.6; margin-top:6px; }
  canvas { display:block; }
  .coord-label { font-size:10px; color:#00FF00; text-shadow: 0 0 4px rgba(0,255,0,0.4); }
</style>
</head>
<body>
  <div id="ui">
    <div id="title">TBFL_6 — Web Visualizer</div>
    <button id="btn-mic">Mikrofon (Live)</button>
    <label for="wavfile">WAV laden</label>
    <input id="wavfile" type="file" accept=".wav,audio/wav" />
    <button id="btn-stop">Stop</button>
    <div id="hint">Allow mic for live input. On iOS need HTTPS or localhost.</div>
  </div>

  <script>
  // ===============================
  // Setup Three.js Scene
  // ===============================
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 10000);
  camera.position.set(0, 300, 800);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  // CSS2DRenderer for small labels
  const labelRenderer = new THREE.CSS2DRenderer();
  labelRenderer.setSize(innerWidth, innerHeight);
  labelRenderer.domElement.style.position = 'absolute';
  labelRenderer.domElement.style.top = '0px';
  labelRenderer.domElement.style.pointerEvents = 'none';
  document.body.appendChild(labelRenderer.domElement);

  // Controls (for debug / interaction)
  const controls = new THREE.OrbitControls(camera, labelRenderer.domElement);
  controls.enablePan = false; controls.enableZoom = false; // keep retro rotation controlled by script
  controls.enabled = false;

  // Lights — subtle green tint
  const ambient = new THREE.AmbientLight(0x00ff00, 0.08);
  scene.add(ambient);

  // Retro grid — faint
  const gridHelper = new THREE.GridHelper(2000, 40, 0x003300, 0x003300);
  gridHelper.material.opacity = 0.06; gridHelper.material.transparent = true;
  gridHelper.position.y = 0;
  scene.add(gridHelper);

  // ===============================
  // Audio Setup
  // ===============================
  let audioCtx = null;
  let analyser = null;
  let sourceNode = null;
  let dataArray = null;
  let freqBinCount = 0;
  let running = false;
  const FFT_SIZE = 2048; // tradeoff between resolution and CPU
  const DURATION = 0.1; // not used directly here; we sample per RAF
  const NOISE_THRESHOLD = 0.0015; // RMS threshold

  // storage for recent points (same semantics as your deque)
  const maxPoints = 40; // adjustable for performance on mobile
  const freqs = []; const louds = []; const cents = [];

  // ===============================
  // Geometry & Materials (preallocated)
  // ===============================
  const maxCapacity = maxPoints;
  const positions = new Float32Array(maxCapacity * 3);
  const colors = new Float32Array(maxCapacity * 3);
  const sizes = new Float32Array(maxCapacity);

  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3).setUsage(THREE.DynamicDrawUsage));
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3).setUsage(THREE.DynamicDrawUsage));
  geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1).setUsage(THREE.DynamicDrawUsage));

  const material = new THREE.ShaderMaterial({
    vertexColors: true,
    transparent: true,
    depthTest: true,
    uniforms: {
      pointScale: { value: window.innerHeight / 2.0 }
    },
    vertexShader: `
      attribute float size;
      varying vec3 vColor;
      void main() {
        vColor = color;
        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
        gl_Position = projectionMatrix * mvPosition;
        // size attenuation by distance
        gl_PointSize = size * (300.0 / -mvPosition.z);
      }
    `,
    fragmentShader: `
      varying vec3 vColor;
      void main() {
        // square point (not circular)
        gl_FragColor = vec4(vColor, 1.0);
      }
    `
  });

  const points = new THREE.Points(geometry, material);
  scene.add(points);

  // Lines as a single LineSegments object (preallocated)
  const linePositions = new Float32Array((maxCapacity - 1) * 2 * 3); // (segments)*(2 points)*(xyz)
  const lineGeom = new THREE.BufferGeometry();
  lineGeom.setAttribute('position', new THREE.BufferAttribute(linePositions, 3).setUsage(THREE.DynamicDrawUsage));
  const lineMat = new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, linewidth: 1, opacity: 0.9 });
  const lines = new THREE.LineSegments(lineGeom, lineMat);
  scene.add(lines);

  // Label cache (CSS2D) — create only when needed and only for every Nth point
  const labelObjects = [];
  const LABEL_EVERY = 5; // only label every 5th point to save performance on iOS

  // Helper: map frequency -> x (log scale)
  const FMIN = 20;
  const FMAX = 22050;
  function freqToX(f) {
    const logMin = Math.log10(FMIN);
    const logMax = Math.log10(FMAX);
    const v = Math.log10(Math.max(f, FMIN));
    const t = (v - logMin) / (logMax - logMin); // 0..1
    const span = 1400; // visual width
    return (t - 0.5) * span; // center at 0
  }

  // map centroid (y) and loudness (z)
  function centroidToY(c) { return (c/2000.0)*800; } // scale guess, will autoscale later
  function loudToZ(l) { return Math.min(Math.max(l*5.0, 0.001), 1.5); } // loudness scaled

  // Compute RMS on time domain
  function computeRMS(timeData) {
    let sum = 0.0;
    for (let i=0;i<timeData.length;i++){ const v = timeData[i]; sum += v*v; }
    return Math.sqrt(sum / timeData.length);
  }

  // Compute centroid from freqMagnitudes (linear mags) and bin freq centers
  function computeCentroid(mags, binFreqs) {
    let num = 0.0, den = 0.0;
    for (let i=0;i<mags.length;i++){
      const m = mags[i];
      num += binFreqs[i]*m;
      den += m;
    }
    return den>0 ? num/den : 0;
  }

  // ===============================
  // Audio chain creation helpers
  // ===============================
  async function startMic() {
    if (running) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    sourceNode = audioCtx.createMediaStreamSource(stream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = FFT_SIZE;
    analyser.smoothingTimeConstant = 0.65;
    freqBinCount = analyser.frequencyBinCount;
    dataArray = new Float32Array(freqBinCount);

    sourceNode.connect(analyser);
    running = true;
  }

  async function startWav(file) {
    if (running) stopAll();
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const arrayBuffer = await file.arrayBuffer();
    const buffer = await audioCtx.decodeAudioData(arrayBuffer);
    const bufferSource = audioCtx.createBufferSource();
    bufferSource.buffer = buffer;
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = FFT_SIZE;
    analyser.smoothingTimeConstant = 0.65;
    freqBinCount = analyser.frequencyBinCount;
    dataArray = new Float32Array(freqBinCount);

    bufferSource.connect(analyser);
    analyser.connect(audioCtx.destination);
    bufferSource.start();
    sourceNode = bufferSource;
    running = true;
    // stop when finished
    bufferSource.onended = () => { running = false; };
  }

  function stopAll() {
    running = false;
    try { if (sourceNode && sourceNode.stop) sourceNode.stop(); } catch(e){}
    try { if (audioCtx && audioCtx.close) audioCtx.close(); } catch(e){}
    sourceNode = null; analyser = null; audioCtx = null;
  }

  // ===============================
  // UI hooks
  // ===============================
  document.getElementById('btn-mic').addEventListener('click', async () => {
    try {
      await startMic();
    } catch (err) {
      alert("Fehler beim Zugriff auf Mikrofon:\n" + err.message);
    }
  });

  document.getElementById('wavfile').addEventListener('change', (ev) => {
    const f = ev.target.files[0];
    if (f) startWav(f);
  });

  document.getElementById('btn-stop').addEventListener('click', () => {
    stopAll();
  });

  // ===============================
  // Animation / Update loop
  // ===============================
  let rot = 0;
  let lastTime = performance.now();

  function animate(now) {
    requestAnimationFrame(animate);
    const dt = (now - lastTime) / 1000.0;
    lastTime = now;

    rot += 0.3 * (dt*60); // keep rotation speed roughly independent of dt
    camera.position.x = Math.sin(rot * 0.01) * 800;
    camera.position.z = Math.cos(rot * 0.01) * 800;
    camera.lookAt(0,200,0);

    if (running && analyser) {
      // get time domain for RMS
      const timeData = new Float32Array(analyser.fftSize);
      analyser.getFloatTimeDomainData(timeData);
      const rms = computeRMS(timeData);

      // get frequency data in dB, convert to linear magnitude
      const freqDb = new Float32Array(freqBinCount);
      analyser.getFloatFrequencyData(freqDb);
      const mags = new Float32Array(freqBinCount);
      const binFreqs = new Float32Array(freqBinCount);
      const nyquist = audioCtx.sampleRate / 2;
      for (let i=0;i<freqBinCount;i++){
        mags[i] = Math.pow(10, freqDb[i] / 20.0); // dB -> linear
        binFreqs[i] = (i / freqBinCount) * nyquist;
      }

      // find dominant freq (peak)
      let maxIdx = 0;
      let maxVal = -Infinity;
      for (let i=1;i<mags.length;i++){ if (mags[i] > maxVal){ maxVal = mags[i]; maxIdx = i; } }
      const dominantFreq = binFreqs[maxIdx] || 0;
      const centroid = computeCentroid(mags, binFreqs) || 0;

      if (rms >= NOISE_THRESHOLD) {
        // push into circular structure
        if (freqs.length >= maxPoints) { freqs.shift(); louds.shift(); cents.shift(); }
        freqs.push(dominantFreq);
        louds.push(rms);
        cents.push(centroid);
      }
    }

    // Update geometry from arrays
    const n = freqs.length;
    // set defaults to invisible for unused entries
    for (let i=0;i<maxCapacity;i++){
      const pi = i*3;
      if (i < n) {
        const f = Math.max(freqs[i], 20);
        const x = freqToX(f);
        const y = centroidToY(cents[i] || 0);
        const z = loudToZ(louds[i] || 0);
        positions[pi] = x; positions[pi+1] = y; positions[pi+2] = z;

        // Age-based color: newer points brighter (green)
        const age = i / Math.max(1, n-1); // 0..1
        const g = age * 1.0;
        const r = age * 0.2;
        colors[pi] = r; colors[pi+1] = g; colors[pi+2] = 0.0;

        sizes[i] = 8.0;
      } else {
        positions[pi] = 1e6; positions[pi+1] = 1e6; positions[pi+2] = 1e6;
        colors[pi]=0; colors[pi+1]=0; colors[pi+2]=0;
        sizes[i] = 0.0;
      }
    }
    geometry.attributes.position.needsUpdate = true;
    geometry.attributes.color.needsUpdate = true;
    geometry.attributes.size.needsUpdate = true;

    // Update lines
    // we write segments for i->i+1
    let lp = 0;
    for (let i=0;i<n-1;i++){
      const iA = i*3, iB=(i+1)*3;
      linePositions[lp++] = positions[iA];   linePositions[lp++] = positions[iA+1];   linePositions[lp++] = positions[iA+2];
      linePositions[lp++] = positions[iB];   linePositions[lp++] = positions[iB+1];   linePositions[lp++] = positions[iB+2];
    }
    // clear rest
    for (; lp < linePositions.length; lp++) linePositions[lp] = 1e6;
    lineGeom.attributes.position.needsUpdate = true;

    // Update labels (only every LABEL_EVERY)
    // Reuse DOM elements
    let li = 0;
    for (let i=0;i<n;i++){
      if (i % LABEL_EVERY !== 0) continue;
      const idx = i / LABEL_EVERY | 0;
      const x = positions[i*3], y = positions[i*3+1], z = positions[i*3+2];
      const txt = `(${Math.round(freqs[i])},${Math.round(cents[i]||0)},${(louds[i]||0).toFixed(2)})`;
      if (!labelObjects[idx]) {
        const div = document.createElement('div');
        div.className = 'coord-label';
        div.textContent = txt;
        const label = new THREE.CSS2DObject(div);
        label.position.set(x, y, z);
        scene.add(label);
        labelObjects[idx] = label;
      } else {
        const label = labelObjects[idx];
        label.element.textContent = txt;
        label.position.set(x, y, z);
      }
      li++;
    }
    // hide unused labels
    for (let j=li;j<labelObjects.length;j++){
      if (labelObjects[j] && labelObjects[j].element) labelObjects[j].element.style.display = 'none';
    }
    for (let k=0;k<li;k++){ if (labelObjects[k] && labelObjects[k].element) labelObjects[k].element.style.display = 'block'; }

    renderer.render(scene, camera);
    labelRenderer.render(scene, camera);
  }

  requestAnimationFrame(animate);

  // ===============================
  // Resize handling
  // ===============================
  window.addEventListener('resize', () => {
    camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
    labelRenderer.setSize(innerWidth, innerHeight);
  });

  // ===============================
  // Helpful note for iOS users
  // ===============================
  console.log("TBFL_6 Web Visualizer ready. Use 'Mikrofon' or load a WAV file.");

  </script>
</body>
</html>
